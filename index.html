<!doctype html>
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Happy Coin — Undertale-style Combat (SFX)</title>
<style>
  :root{
    --bg1:#070709; --bg2:#121217; --accent:#00ffea; --danger:#ff004c; --purple:#7d00b2;
  }
  *{box-sizing:border-box;font-family:Tahoma, Arial, sans-serif}
  body{
    margin:0; min-height:100vh; background:linear-gradient(180deg,var(--bg1),var(--bg2));
    color:#e9eef0; display:flex; flex-direction:column; align-items:center; gap:12px; padding:18px;
  }
  header{width:100%; max-width:1100px; display:flex; justify-content:space-between; align-items:center; gap:8px}
  h1{color:var(--accent); font-size:1.4rem; margin:0}
  .top-stats{display:flex; gap:10px; align-items:center; font-size:0.95rem}
  .chip{background:#0e0e10;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  main{width:100%; max-width:1100px; display:flex; flex-direction:column; align-items:center; gap:12px}
  .card{width:100%; background:linear-gradient(180deg,#0b0b0d, #101012); border-radius:12px; padding:14px; box-shadow:0 6px 20px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03)}
  .battle-area{display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; width:100%}
  .arena{background:linear-gradient(180deg,#0d0d0f,#0b0b0d); border-radius:10px; padding:12px; display:flex; flex-direction:column; align-items:center; width:100%; max-width:720px}
  canvas{background:transparent; border-radius:8px; display:block; touch-action: none;}
  .hud{width:100%; display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:8px}
  .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .btn{background:var(--accent); color:#001; border:none; padding:10px 14px; border-radius:8px; font-weight:700; cursor:pointer}
  .btn.secondary{background:#222; color:#eaeaea; border:1px solid rgba(255,255,255,0.03)}
  .btn.ghost{background:transparent; border:1px dashed rgba(255,255,255,0.04)}
  .status{font-size:0.95rem}
  .log{background:#0b0b0d; width:100%; max-width:980px; padding:12px; border-radius:10px; font-size:0.9rem; max-height:220px; overflow:auto; border:1px solid rgba(255,255,255,0.02)}
  .small{font-size:0.87rem; opacity:0.9}
  .made-by{font-weight:700; color:#ffd59a; margin-top:6px}
  .timing-ui{width:100%; max-width:400px; height:36px; background:#111; border-radius:8px; border:1px solid rgba(255,255,255,0.04); position:relative; overflow:hidden; margin-top:10px}
  .timing-bar-pointer{position:absolute; top:0; bottom:0; width:6px; background:var(--accent); transform:translateX(-50%); left:0}
  .timing-bar-sweet{position:absolute; top:6px; bottom:6px; height:calc(100% - 12px); border-radius:6px; background:rgba(0,255,170,0.18); left:40%; width:20%;}
  .arena-top{display:flex; gap:12px; width:100%; justify-content:space-between; align-items:center; margin-bottom:6px}
  .hp{text-align:center}
  @media (max-width:720px){
    .arena{max-width:100%}
  }
</style>
</head>
<body>
<header>
  <h1>Happy Coin: Crypto War — SFX</h1>
  <div class="top-stats">
    <div class="chip">رمز ارز: <strong id="coins">0</strong> 🪙</div>
    <div class="chip">دیتاسنتر: <strong id="dcCount">0</strong></div>
    <div class="chip">قیمت بعدی DC: <strong id="dcCost">50</strong> 🪙</div>
  </div>
</header>

<main>
  <section class="card">
    <div class="battle-area">
      <div class="arena" id="arenaContainer" aria-live="polite">
        <div class="arena-top">
          <div class="hp">باس: <span id="bossHPText">HP: 300</span></div>
          <div class="hp">تو: <span id="playerHPText">HP: 100</span></div>
        </div>

        <!-- canvas for bullets and player -->
        <canvas id="arenaCanvas" width="720" height="360" style="max-width:100%; width:100%; height:auto;"></canvas>

        <div class="hud">
          <div class="controls">
            <button class="btn" id="attackBtn">حمله (شروع مینی‌گیم)</button>
            <button class="btn secondary" id="actBtn">Act</button>
            <button class="btn secondary" id="buyDCBtn">خرید دیتاسنتر</button>
            <button class="btn ghost" id="retreatBtn" style="display:none">فرار</button>
          </div>
          <div class="status"><span id="statusText">آماده</span> — مرحله: <strong id="currentStageText">—</strong></div>
        </div>

        <!-- timing minigame -->
        <div id="timingUI" class="timing-ui" style="display:none" aria-hidden="true">
          <div id="sweetZone" class="timing-bar-sweet"></div>
          <div id="pointer" class="timing-bar-pointer" style="left:0px"></div>
        </div>

      </div>

      <div style="flex:1; max-width:360px;">
        <div class="card" style="margin-bottom:12px;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>جزئیات باس</div>
            <div class="small">سختی: <span id="stageDiff">—</span></div>
          </div>
          <div style="height:8px"></div>
          <div class="log" id="log">> خوش آمدی! مرحله‌ای انتخاب کن و بجنگ.</div>
        </div>

        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
            <div>کنترل‌ها</div>
            <div class="small">حرکت: فلش‌ها یا درگ / حمله: دکمه یا Space</div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button class="btn secondary" id="openStagesBtn">انتخاب مرحله</button>
            <button class="btn secondary" id="resetBtn">ریست ذخیره</button>
          </div>
        </div>
      </div>
    </div>
  </section>
</main>

<!-- Stages modal (simple) -->
<div id="stageModal" style="position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;padding:18px;z-index:60">
  <div style="background:linear-gradient(180deg,#0b0b0d,#0f0f11);padding:14px;border-radius:10px;max-width:720px;width:100%;border:1px solid rgba(255,255,255,0.03)">
    <h3 style="margin:0 0 8px 0">انتخاب مرحله</h3>
    <div id="stagesGrid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;max-height:60vh;overflow:auto;padding:6px"></div>
    <div style="text-align:center;margin-top:8px"><button class="btn secondary" id="closeStageModal">بستن</button></div>
  </div>
</div>

<footer style="width:100%;max-width:1100px;margin-top:12px;text-align:center;color:#cfd8dc">
  <div>نسخه آزمایشی — نسخه Undertale-like + SFX</div>
  <div class="made-by">ساخته شده توسط Rob Lucci</div>
</footer>

<script>
/* ================= Audio (Web Audio API SFX) ================= */
let audioCtx = null;
let audioReady = false;

function initAudioContext(){
  if (audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioReady = true;
  }catch(e){
    console.warn('AudioContext not supported', e);
    audioReady = false;
  }
}

// ensure resume on user gesture (some browsers keep it suspended)
function ensureAudioResume(){
  if (!audioCtx) initAudioContext();
  if (!audioCtx) return;
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().then(()=>{ /* resumed */ }).catch(()=>{});
  }
}

// helper to create short beep with envelope
function playBeep(freq, duration=0.12, type='sine', volume=0.12){
  if (!audioCtx) initAudioContext();
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = volume;
  o.connect(g);
  g.connect(audioCtx.destination);
  g.gain.setValueAtTime(volume, now);
  g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
  o.start(now);
  o.stop(now + duration + 0.02);
}

// attack sound: small two-tone staccato
function playAttack(){
  ensureAudioResume();
  if (!audioCtx) return;
  playBeep(640, 0.08, 'sawtooth', 0.12);
  setTimeout(()=> playBeep(940, 0.06, 'sine', 0.10), 80);
}

// hurt sound: short buzzy low hit
function playHurt(){
  ensureAudioResume();
  if (!audioCtx) return;
  // quick square with short noise-like effect by detuning
  playBeep(160, 0.12, 'square', 0.16);
  setTimeout(()=> playBeep(220, 0.09, 'sawtooth', 0.08), 40);
}

// win sound: small chord
function playWin(){
  ensureAudioResume();
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const freqs = [440, 660, 880];
  const gain = audioCtx.createGain();
  gain.gain.value = 0.14;
  gain.connect(audioCtx.destination);
  const oscs = freqs.map((f)=>{ const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value = f; o.connect(gain); return o; });
  oscs.forEach(o=>o.start(now));
  gain.gain.setValueAtTime(0.14, now);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);
  oscs.forEach(o=>o.stop(now + 0.72));
}

/* resume audio on first interaction */
function attachAutoAudioResume(){
  const resume = ()=>{ ensureAudioResume(); document.removeEventListener('pointerdown', resume); document.removeEventListener('keydown', resume); };
  document.addEventListener('pointerdown', resume);
  document.addEventListener('keydown', resume);
}
attachAutoAudioResume();

/* ================= helpers storage & safe log ================= */
function readNumber(key,fallback){
  try{ const v=localStorage.getItem(key); if(v===null) return fallback; const n=Number(v); return isNaN(n)?fallback:n; }catch(e){return fallback;}
}
function saveNumber(key,val){ try{ localStorage.setItem(key,String(val)); }catch(e){} }
function safeLog(msg){
  const el = document.getElementById('log');
  const esc = String(msg).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  el.innerHTML = '> ' + esc + '<br>' + el.innerHTML;
}

/* -------------------- game state -------------------- */
const TOTAL_STAGES = 34;
let coins = readNumber('hc_coins', 0);
let dcCount = readNumber('hc_dcCount', 0);
let dcCost = readNumber('hc_dcCost', 50);
let unlockedStage = readNumber('hc_unlocked', 1) || 1;

const BASE_PLAYER_MAX_HP = 100;
let playerMaxHP = BASE_PLAYER_MAX_HP + dcCount * 25;
let playerHP = playerMaxHP;

let currentStage = 0;
let bossMaxHP = 300;
let bossHP = bossMaxHP;
let bossAttackBase = 8;

let bossAlive = false;
let spawnIntervalId = null;
let rafId = null;
let bullets = []; // projectile list
let pointerX = 0, pointerY = 0;
let isDragging = false;

/* DOM refs */
const coinsEl = document.getElementById('coins');
const dcCountEl = document.getElementById('dcCount');
const dcCostEl = document.getElementById('dcCost');
const bossHPText = document.getElementById('bossHPText');
const playerHPText = document.getElementById('playerHPText');
const statusText = document.getElementById('statusText');
const currentStageText = document.getElementById('currentStageText');
const stageDiffEl = document.getElementById('stageDiff');

const canvas = document.getElementById('arenaCanvas');
const ctx = canvas.getContext('2d');
const attackBtn = document.getElementById('attackBtn');
const buyDCBtn = document.getElementById('buyDCBtn');
const retreatBtn = document.getElementById('retreatBtn');
const openStagesBtn = document.getElementById('openStagesBtn');
const stageModal = document.getElementById('stageModal');
const stagesGrid = document.getElementById('stagesGrid');
const closeStageModal = document.getElementById('closeStageModal');
const timingUI = document.getElementById('timingUI');
const pointerEl = document.getElementById('pointer');
const sweetZoneEl = document.getElementById('sweetZone');
const resetBtn = document.getElementById('resetBtn');

/* player (heart) representation */
let player = {
  x: 120,
  y: canvas.height / 2,
  size: 18,
  speed: 300 // px/sec
};

/* difficulty formulas */
function damageMultiplier(){ return 1 + dcCount * 0.35; }
function computeBossHPForStage(stage){ return Math.round(300 * Math.pow(1.5, stage-1)); }
function computeBossAttackBase(stage){ return Math.round(8 * Math.pow(1.22, stage-1)); }

/* -------------------- UI helpers -------------------- */
function updateUI(){
  coinsEl.innerText = Math.round(coins);
  dcCountEl.innerText = dcCount;
  dcCostEl.innerText = Math.round(dcCost);
  bossHPText.innerText = 'HP: ' + Math.max(0,Math.round(bossHP)) + ' / ' + Math.round(bossMaxHP);
  playerHPText.innerText = 'HP: ' + Math.max(0,Math.round(playerHP)) + ' / ' + Math.round(playerMaxHP);
  currentStageText.innerText = currentStage ? currentStage : '—';
  saveNumber('hc_coins', coins);
  saveNumber('hc_dcCount', dcCount);
  saveNumber('hc_dcCost', dcCost);
  saveNumber('hc_unlocked', unlockedStage);
}

/* -------------------- projectiles & physics -------------------- */
function spawnBulletAt(angle, speed, size=8, color='rgba(255,80,80,0.95)'){
  const spawnX = canvas.width - 60;
  const spawnY = canvas.height / 2;
  bullets.push({
    x: spawnX,
    y: spawnY,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    r: size,
    color
  });
}
function spawnAimedBulletTowardsPlayer(speed, spread=0){
  const sx = canvas.width - 60;
  const sy = canvas.height / 2;
  const dx = player.x - sx;
  const dy = player.y - sy;
  const baseAngle = Math.atan2(dy,dx);
  const angle = baseAngle + (Math.random()*2-1) * spread;
  spawnBulletAt(angle, speed);
}
function cleanupBullets(){
  bullets = bullets.filter(b => b.x + b.r > -50 && b.x - b.r < canvas.width + 50 && b.y + b.r > -50 && b.y - b.r < canvas.height + 50);
}
/* collision circle-rect */
function rectCircleColliding(circle, rect){
  const distX = Math.abs(circle.x - (rect.x + rect.w/2));
  const distY = Math.abs(circle.y - (rect.y + rect.h/2));
  if (distX > (rect.w/2 + circle.r)) return false;
  if (distY > (rect.h/2 + circle.r)) return false;
  if (distX <= (rect.w/2)) return true;
  if (distY <= (rect.h/2)) return true;
  const dx = distX - rect.w/2;
  const dy = distY - rect.h/2;
  return (dx*dx + dy*dy <= (circle.r*circle.r));
}

/* -------------------- animation & loop -------------------- */
let lastFrame = performance.now();
function rafLoop(now){
  const dt = (now - lastFrame) / 1000;
  lastFrame = now;
  updatePhysics(dt);
  render();
  rafId = requestAnimationFrame(rafLoop);
}
function updatePhysics(dt){
  for(const b of bullets){
    b.x += b.vx * dt;
    b.y += b.vy * dt;
  }
  cleanupBullets();

  const playerRect = { x: player.x - player.size/2, y: player.y - player.size/2, w: player.size, h: player.size };
  for (let i = bullets.length - 1; i >= 0; i--){
    if (rectCircleColliding(bullets[i], playerRect)){
      const dmg = Math.max(1, Math.round(6 + Math.random()*6));
      playerHP -= dmg;
      // play hurt SFX
      playHurt();
      safeLog('حمله برخورد کرد — ' + dmg + ' دمیج');
      bullets.splice(i,1);
      if (playerHP <= 0){
        playerHP = 0;
        updateUI();
        endFight(false);
        return;
      }
      updateUI();
    }
  }
}
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const bossX = canvas.width - 60, bossY = canvas.height/2;
  ctx.beginPath();
  ctx.fillStyle = 'rgba(125,0,178,0.12)';
  ctx.arc(bossX, bossY, 36, 0, Math.PI*2);
  ctx.fill();
  ctx.closePath();
  ctx.beginPath();
  ctx.fillStyle = '#ff6b6b';
  ctx.arc(bossX - 12, bossY - 8, 6, 0, Math.PI*2);
  ctx.arc(bossX + 12, bossY - 8, 6, 0, Math.PI*2);
  ctx.fill();
  ctx.closePath();

  for(const b of bullets){
    ctx.beginPath();
    ctx.fillStyle = b.color;
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();
    ctx.closePath();
  }

  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.rotate(Math.sin(performance.now()/200)*0.05);
  ctx.fillStyle = '#ffd59a';
  const s = player.size;
  ctx.fillRect(-s/2, -s/2, s, s);
  ctx.restore();
}

/* -------------------- boss attack patterns -------------------- */
function startSpawningBullets(stage){
  stopSpawningBullets();
  const baseSpeed = 120 + (stage-1)*18;
  const spawnInterval = Math.max(420, 900 - (stage-1)*18);
  spawnIntervalId = setInterval(()=>{
    if (!bossAlive) return;
    const r = Math.random();
    if (r < 0.45){
      spawnAimedBulletTowardsPlayer(baseSpeed * (0.9 + Math.random()*0.4), 0.18);
    } else if (r < 0.75){
      const bulletsCount = 4;
      const centerAngle = Math.atan2(player.y - canvas.height/2, player.x - (canvas.width - 60));
      for(let i=0;i<bulletsCount;i++){
        const angle = centerAngle + (i - (bulletsCount-1)/2) * 0.22;
        spawnBulletAt(angle, baseSpeed * 0.9 + i*8, 7);
      }
    } else {
      const fromTop = Math.random() < 0.5;
      const y = fromTop ? 40 : canvas.height - 40;
      const sx = canvas.width - 60;
      for(let i=0;i<6;i++){
        bullets.push({
          x: sx + i*6,
          y: y + i*10,
          vx: - (baseSpeed + i*6) * 0.9,
          vy: (fromTop ? 1 : -1) * (20 + i*6) * 0.04,
          r: 6,
          color: 'rgba(255,120,60,0.95)'
        });
      }
    }
  }, spawnInterval);
}
function stopSpawningBullets(){
  if (spawnIntervalId){ clearInterval(spawnIntervalId); spawnIntervalId = null; }
}

/* -------------------- fight flow -------------------- */
function startStage(stage){
  if (bossAlive) { safeLog('در حال مبارزه‌ای — اول تمومش کن یا فرار کن.'); return; }
  currentStage = stage;
  bossMaxHP = computeBossHPForStage(stage);
  bossHP = bossMaxHP;
  bossAttackBase = computeBossAttackBase(stage);
  playerMaxHP = BASE_PLAYER_MAX_HP + dcCount * 25;
  playerHP = playerMaxHP;
  bossAlive = true;
  bullets = [];
  safeLog('مرحله '+stage+' شروع شد — باس HP: ' + bossMaxHP);
  statusText.innerText = 'مبارزه (مرحله '+stage+')';
  retreatBtn.style.display = 'inline-block';
  startSpawningBullets(stage);
  if (!rafId){ lastFrame = performance.now(); rafId = requestAnimationFrame(rafLoop); }
  updateUI();
}

function endFight(victory){
  bossAlive = false;
  stopSpawningBullets();
  if (spawnIntervalId){ clearInterval(spawnIntervalId); spawnIntervalId = null; }
  if (rafId){ cancelAnimationFrame(rafId); rafId = null; }
  bullets = [];
  retreatBtn.style.display = 'none';
  timingUI.style.display = 'none';
  timingUI.setAttribute('aria-hidden','true');
  hideTouchDrag();
  if (victory){
    // play win SFX
    playWin();
    const reward = Math.round(100 * Math.max(1,currentStage) * (1 + dcCount*0.08));
    coins += reward;
    safeLog('تبریک! باس شکست خورد — +' + reward + ' سکه');
    if (currentStage < TOTAL_STAGES && unlockedStage <= currentStage) unlockedStage = currentStage + 1;
    playerMaxHP = BASE_PLAYER_MAX_HP + dcCount * 25;
    playerHP = playerMaxHP;
    statusText.innerText = 'برنده شدی!';
  } else {
    const loss = Math.min(coins, Math.round(10 * Math.max(1,currentStage)));
    coins -= loss;
    safeLog('شکست خوردی — از دست دادی ' + loss + ' سکه');
    playerMaxHP = BASE_PLAYER_MAX_HP + dcCount * 25;
    playerHP = Math.max(1, Math.round(playerMaxHP * 0.3));
    statusText.innerText = 'شکست خوردی';
  }
  currentStage = 0;
  updateUI();
}

/* retreat */
retreatBtn.addEventListener('click', ()=>{
  if (!bossAlive) return;
  safeLog('فرار کردی از مبارزه.');
  endFight(false);
});

/* -------------------- attack minigame (timing) -------------------- */
let timing = {
  running: false,
  pos: 0, // 0..1
  speed: 1.6,
  sweetLeft: 0.25, sweetWidth: 0.18
};

function startTimingMinigame(){
  if (!bossAlive) { safeLog('الان باس نیست.'); return; }
  if (timing.running) return;

  // prepare sweet zone and pointer
  const baseWidth = 0.18;
  timing.sweetWidth = Math.min(0.45, baseWidth + dcCount * 0.02);
  timing.sweetLeft = Math.max(0.08, Math.min(0.78, 0.25 + (Math.random() * 0.5 - 0.15)));
  timing.pos = 0;
  timing.running = true;
  timing.startTime = performance.now();
  timingUI.style.display = 'block';
  timingUI.setAttribute('aria-hidden','false');

  // visually update sweet zone
  const parentWidth = timingUI.clientWidth || 300;
  sweetZoneEl.style.left = (timing.sweetLeft * 100) + '%';
  sweetZoneEl.style.width = (timing.sweetWidth * 100) + '%';

  // pause spawning while focusing on minigame
  const hadSpawn = !!spawnIntervalId;
  if (spawnIntervalId){ stopSpawningBullets(); }

  // define listeners in outer scope so we can remove them reliably
  let onKey = null;
  let clickHandler = null;

  function finishTiming(userPressed){
    if (!timing.running) return;
    timing.running = false;
    timingUI.style.display = 'none';
    timingUI.setAttribute('aria-hidden','true');

    // remove listeners (safe even if not attached)
    window.removeEventListener('keydown', onKey);
    attackBtn.removeEventListener('click', clickHandler);

    // compute quality
    const now = performance.now();
    const elapsed = (now - timing.startTime) / 1000;
    const winPos = timing.pos;
    const left = timing.sweetLeft;
    const right = timing.sweetLeft + timing.sweetWidth;
    let quality = 0;
    if (winPos >= left && winPos <= right){
      const center = (left + right)/2;
      const dist = Math.abs(winPos - center) / (timing.sweetWidth/2);
      quality = (dist < 0.18) ? 3 : (dist < 0.45 ? 2 : 1);
    } else {
      quality = 0;
    }

    let baseDamage;
    if (quality === 3) baseDamage = Math.round(45 + Math.random()*12);
    else if (quality === 2) baseDamage = Math.round(28 + Math.random()*10);
    else if (quality === 1) baseDamage = Math.round(16 + Math.random()*8);
    else baseDamage = Math.round(6 + Math.random()*6);

    const dmg = Math.round(baseDamage * damageMultiplier());
    bossHP -= dmg;
    const reward = Math.round(8 * Math.max(1,currentStage) * (1 + quality*0.25));
    coins += reward;

    // play attack SFX
    playAttack();

    safeLog('تو حمله زدی — کیفیت: ' + (['Fail','OK','Great','Perfect'][quality]) + ' | ' + dmg + ' دمیج — +' + reward + ' سکه');
    updateUI();

    // resume spawn if needed
    setTimeout(()=>{ if (hadSpawn && bossAlive) startSpawningBullets(currentStage); }, 300);

    if (bossHP <= 0){
      bossHP = 0;
      updateUI();
      endFight(true);
    }
  }

  // pointer animation loop
  function step(){
    if (!timing.running) return;
    const now = performance.now();
    const elapsed = (now - timing.startTime) / 1000;
    timing.pos = (Math.sin(elapsed * Math.PI * timing.speed - Math.PI/2) + 1) / 2;
    const parentW = timingUI.clientWidth || parentWidth;
    const px = timing.pos * parentW;
    pointerEl.style.left = px + 'px';

    if (elapsed > 3.2){
      // auto-fail
      finishTiming(false);
      return;
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);

  // listeners (defined as variables so they can be removed by finishTiming)
  onKey = function(e){
    // prevent page scroll with space
    if (e.key === ' ' || e.key === 'Spacebar') { e.preventDefault(); }
    if (!timing.running) return;
    if (e.key === ' ' || e.key === 'Spacebar' || e.key === 'Enter'){
      finishTiming(true);
    }
  };
  window.addEventListener('keydown', onKey);

  clickHandler = function(){ if (timing.running) finishTiming(true); };
  attackBtn.addEventListener('click', clickHandler);
}

/* -------------------- input: keyboard & touch drag -------------------- */
const keys = {};
window.addEventListener('keydown', (e)=>{ keys[e.key] = true; });
window.addEventListener('keyup', (e)=>{ keys[e.key] = false; });

let lastMoveTime = performance.now();
function handlePlayerMovement(){
  const now = performance.now();
  const dt = (now - lastMoveTime) / 1000;
  lastMoveTime = now;
  let dx = 0, dy = 0;
  if (keys['ArrowLeft'] || keys['a'] || keys['A']) dx -= 1;
  if (keys['ArrowRight'] || keys['d'] || keys['D']) dx += 1;
  if (keys['ArrowUp'] || keys['w'] || keys['W']) dy -= 1;
  if (keys['ArrowDown'] || keys['s'] || keys['S']) dy += 1;
  const len = Math.hypot(dx,dy);
  if (len > 0){
    dx /= len; dy /= len;
    player.x += dx * player.speed * dt;
    player.y += dy * player.speed * dt;
    clampPlayerToCanvas();
  }
  requestAnimationFrame(handlePlayerMovement);
}
function clampPlayerToCanvas(){
  const margin = 6;
  player.x = Math.max(margin, Math.min(canvas.width - margin - 160, player.x));
  player.y = Math.max(margin, Math.min(canvas.height - margin, player.y));
}

/* touch drag */
let touchActive = false;
function setupTouchDrag(){
  function moveFromEvent(e){
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : (e.changedTouches ? e.changedTouches[0] : null);
    const clientX = touch ? touch.clientX : (e.clientX);
    const clientY = touch ? touch.clientY : (e.clientY);
    if (clientX == null) return;
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    player.x = x; player.y = y;
    clampPlayerToCanvas();
  }
  function onStart(e){
    touchActive = true;
    isDragging = true;
    moveFromEvent(e);
  }
  function onMove(e){
    if (!touchActive) return;
    moveFromEvent(e);
  }
  function onEnd(e){
    touchActive = false;
    isDragging = false;
  }
  canvas.addEventListener('touchstart', onStart, {passive:false});
  canvas.addEventListener('touchmove', onMove, {passive:false});
  canvas.addEventListener('touchend', onEnd, {passive:false});
  canvas.addEventListener('mousedown', onStart);
  window.addEventListener('mousemove', (e)=>{ if (isDragging) moveFromEvent(e); });
  window.addEventListener('mouseup', ()=>{ isDragging=false; touchActive=false; });
}
function hideTouchDrag(){ /* listeners harmless to keep */ }

/* -------------------- buy data center & balance -------------------- */
function buyDataCenter(){
  if (coins < dcCost){ safeLog('سکه کافی نداری'); return; }
  coins -= dcCost; dcCount += 1;
  dcCost = Math.min(999999999, Math.round(dcCost * 1.6));
  const oldMax = playerMaxHP;
  playerMaxHP = BASE_PLAYER_MAX_HP + dcCount * 25;
  const hpIncrease = playerMaxHP - oldMax;
  playerHP = Math.min(playerMaxHP, playerHP + Math.round(hpIncrease * 0.7));
  safeLog('دیتاسنتر خریدی — +25 Max HP و HP فعلی افزایش یافت');
  updateUI();
}

/* -------------------- stages grid -------------------- */
function buildStages(){
  stagesGrid.innerHTML = '';
  for(let s=1;s<=TOTAL_STAGES;s++){
    const div = document.createElement('div');
    div.style.padding = '10px';
    div.style.borderRadius = '8px';
    div.style.background = (s <= unlockedStage) ? '#101014' : '#0b0b0d';
    div.style.border = '1px solid rgba(255,255,255,0.03)';
    div.style.cursor = (s <= unlockedStage) ? 'pointer' : 'not-allowed';
    div.innerHTML = '<div style="font-weight:800;color:var(--accent)">مرحله '+s+'</div><div style="font-size:0.85rem;margin-top:6px">'+(s<=4?'آسان':s<=12?'متوسط':s<=24?'سخت':'نهایی')+'</div>';
    if (s <= unlockedStage){
      div.addEventListener('click', ()=>{ startStage(s); closeModal(); });
    } else {
      div.title = 'این مرحله قفل است';
    }
    stagesGrid.appendChild(div);
  }
}
function openModal(){ stageModal.style.display = 'flex'; }
function closeModal(){ stageModal.style.display = 'none'; }

/* -------------------- events -------------------- */
openStagesBtn.addEventListener('click', ()=>{ buildStages(); openModal(); });
closeStageModal.addEventListener('click', closeModal);
attackBtn.addEventListener('click', ()=>{ if (!timing.running) startTimingMinigame(); });
buyDCBtn.addEventListener('click', buyDataCenter);
resetBtn.addEventListener('click', ()=>{ if(confirm('میخوای ذخیره رو ریست کنی؟')){ localStorage.clear(); location.reload(); } });

/* init */
function init(){
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(320, Math.floor(rect.width * dpr));
    canvas.height = Math.max(180, Math.floor(rect.height * dpr * 0.5 + 180));
    clampPlayerToCanvas();
  }
  setTimeout(()=>{ resizeCanvas(); player.x = 120; player.y = canvas.height/2; updateUI(); render(); }, 50);
  window.addEventListener('resize', ()=>{ resizeCanvas(); });

  setupTouchDrag();
  handlePlayerMovement();
  updateUI();
  safeLog('سیستم مبارزه Undertale-style آماده است — مرحله رو انتخاب کن و بجنگ!');
}

window.addEventListener('beforeunload', ()=>{ stopSpawningBullets(); if (rafId) cancelAnimationFrame(rafId); });
window.__hc = { startStage, buyDataCenter, getState: ()=>({coins,dcCount,dcCost,unlockedStage,playerHP,playerMaxHP,bossHP,currentStage}) };
init();
</script>
</body>
</html>